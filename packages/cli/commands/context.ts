/**
 * `glubean context` command — generate an AI-optimized context file.
 *
 * Produces `.glubean/ai-context.md` containing:
 * - SDK quick reference
 * - Existing test patterns from the project
 * - Uncovered endpoints (if OpenAPI spec + trace data available)
 * - Endpoint schemas for uncovered endpoints
 *
 * Designed to be consumed by AI tools (Cursor, Copilot, Codex) via
 * AGENTS.md or direct file reference.
 */

import { relative, resolve } from "@std/path";
import { scan } from "@glubean/scanner";
import { type Endpoint, extractEndpoints, findOpenApiSpec, loadOpenApiSpec, type SchemaInfo } from "../lib/openapi.ts";

const colors = {
  reset: "\x1b[0m",
  bold: "\x1b[1m",
  dim: "\x1b[2m",
  green: "\x1b[32m",
  yellow: "\x1b[33m",
  cyan: "\x1b[36m",
};

/** Trace summary written by `glubean run`. */
interface TraceSummary {
  runAt: string;
  file: string;
  traces: Array<{
    testId: string;
    method: string;
    url: string;
    status: number;
  }>;
}

export interface ContextCommandOptions {
  openapi?: string;
  dir?: string;
  out?: string;
}

export async function contextCommand(
  options: ContextCommandOptions = {},
): Promise<void> {
  const dir = options.dir ? resolve(options.dir) : Deno.cwd();
  const outputPath = options.out ? resolve(options.out) : resolve(dir, ".glubean", "ai-context.md");

  console.log(`\n${colors.bold}${colors.cyan}Glubean Context${colors.reset}\n`);

  const sections: string[] = [];

  // Header
  sections.push(
    "# Glubean AI Context",
    "",
    "> Auto-generated by `glubean context`. Do not edit manually.",
    "> Regenerate with: `glubean context`",
    "",
  );

  // 1. SDK Quick Reference
  sections.push(
    "## SDK Quick Reference",
    "",
    "```typescript",
    'import { test } from "@glubean/sdk";',
    "",
    "// Define a test (always export const)",
    "export const myTest = test(",
    '  { id: "my-test", name: "My Test", tags: ["smoke"] },',
    "  async (ctx) => {",
    "    // Environment variables (from .env)",
    '    const baseUrl = ctx.vars.get("BASE_URL");',
    "",
    "    // Secrets (from .env.secrets, redacted in output)",
    '    const apiKey = ctx.secrets.require("API_KEY");',
    "",
    "    // Logging (persisted, visible in dashboard)",
    '    ctx.log("Starting test...");',
    "",
    "    // HTTP request + trace",
    "    const start = Date.now();",
    "    const res = await fetch(`${baseUrl}/endpoint`);",
    "    const data = await res.json();",
    "    ctx.trace({",
    '      method: "GET",',
    "      url: `${baseUrl}/endpoint`,",
    "      status: res.status,",
    "      duration: Date.now() - start,",
    "      responseBody: data,",
    "    });",
    "",
    "    // Assertions",
    '    ctx.assert(res.status === 200, "Should return 200", {',
    "      actual: res.status,",
    "      expected: 200,",
    "    });",
    "",
    "    // Performance metrics",
    '    ctx.metric("response_time", Date.now() - start, "ms");',
    "",
    "    // Skip test conditionally",
    '    // ctx.skip("Reason to skip");',
    "  }",
    ");",
    "```",
    "",
  );

  // 2. Scan for existing test metadata
  console.log(`${colors.dim}Scanning project...${colors.reset}`);
  let scanResult;
  try {
    scanResult = await scan(dir);
  } catch {
    console.log(
      `${colors.yellow}Warning: Could not scan project for test metadata.${colors.reset}`,
    );
  }

  // 3. Extract test patterns from existing files
  if (scanResult && scanResult.fileCount > 0) {
    sections.push("## Existing Tests", "");

    const fileEntries = Object.entries(scanResult.files);
    sections.push(
      `This project has **${scanResult.testCount} tests** across **${scanResult.fileCount} files**.`,
      "",
    );

    if (scanResult.tags.length > 0) {
      sections.push(
        `**Tags in use:** ${scanResult.tags.map((t) => `\`${t}\``).join(", ")}`,
        "",
      );
    }

    // List all tests grouped by file
    sections.push(
      "| File | Test ID | Name | Tags |",
      "|------|---------|------|------|",
    );
    for (const [filePath, fileMeta] of fileEntries) {
      for (const exp of fileMeta.exports) {
        const tags = exp.tags?.map((t) => `\`${t}\``).join(", ") || "";
        sections.push(
          `| ${filePath} | ${exp.id} | ${exp.name || ""} | ${tags} |`,
        );
      }
    }
    sections.push("");

    // Try to extract a sample test for pattern reference
    const sampleFile = await findSampleTest(dir, fileEntries);
    if (sampleFile) {
      sections.push(
        "### Sample Test Pattern",
        "",
        "Use this as a reference for writing new tests:",
        "",
        "```typescript",
        sampleFile,
        "```",
        "",
      );
    }
  }

  // 4. OpenAPI coverage analysis
  let openapiPath: string | null = null;
  if (options.openapi) {
    openapiPath = resolve(options.openapi);
  } else {
    openapiPath = await findOpenApiSpec(dir);
  }

  if (openapiPath) {
    console.log(
      `${colors.dim}Loading OpenAPI spec: ${relative(dir, openapiPath)}${colors.reset}`,
    );
    try {
      const spec = await loadOpenApiSpec(openapiPath);
      const endpoints = extractEndpoints(spec);

      if (endpoints.length > 0) {
        // Load trace data if available
        let traces: TraceSummary | null = null;
        try {
          const tracesContent = await Deno.readTextFile(
            resolve(dir, ".glubean", "traces.json"),
          );
          traces = JSON.parse(tracesContent) as TraceSummary;
        } catch {
          // No trace data
        }

        // Determine covered endpoints
        const coveredKeys = new Set<string>();
        if (traces) {
          for (const trace of traces.traces) {
            for (const ep of endpoints) {
              if (matchesEndpoint(trace.url, trace.method, ep)) {
                coveredKeys.add(`${ep.method} ${ep.path}`);
              }
            }
          }
        }

        const uncovered = endpoints.filter(
          (ep) => !coveredKeys.has(`${ep.method} ${ep.path}`),
        );

        // All endpoints section
        sections.push(
          "## API Endpoints",
          "",
          `OpenAPI spec: \`${relative(dir, openapiPath)}\``,
          "",
          `Total: ${endpoints.length} endpoints, ${coveredKeys.size} covered, ${uncovered.length} uncovered`,
          "",
        );

        // Uncovered endpoints with schemas (the main value for AI)
        if (uncovered.length > 0) {
          sections.push(
            "## Uncovered Endpoints (generate tests for these)",
            "",
          );
          for (const ep of uncovered) {
            sections.push(`### ${ep.method} ${ep.path}`, "");
            if (ep.summary) {
              sections.push(ep.summary, "");
            }

            // Parameters
            const queryParams = (ep.parameters || []).filter(
              (p) => p.in === "query",
            );
            const pathParams = (ep.parameters || []).filter(
              (p) => p.in === "path",
            );

            if (pathParams.length > 0) {
              sections.push(
                "**Path parameters:**",
                ...pathParams.map(
                  (p) => `- \`${p.name}\` (${p.schema?.type || "string"}${p.required ? ", required" : ""})`,
                ),
                "",
              );
            }

            if (queryParams.length > 0) {
              sections.push(
                "**Query parameters:**",
                ...queryParams.map(
                  (p) => `- \`${p.name}\` (${p.schema?.type || "string"}${p.required ? ", required" : ""})`,
                ),
                "",
              );
            }

            // Request body
            if (ep.requestBody) {
              sections.push(
                "**Request body:**",
                "",
                "```json",
                JSON.stringify(schemaToExample(ep.requestBody), null, 2),
                "```",
                "",
              );
            }

            // Responses
            if (ep.responses) {
              for (const [status, resp] of Object.entries(ep.responses)) {
                sections.push(`**Response ${status}:**`);
                if (resp.description) {
                  sections.push(resp.description);
                }
                if (resp.schema) {
                  sections.push(
                    "",
                    "```json",
                    JSON.stringify(schemaToExample(resp.schema), null, 2),
                    "```",
                  );
                }
                sections.push("");
              }
            }
          }
        }

        // Covered endpoints (brief list)
        const coveredEndpoints = endpoints.filter((ep) => coveredKeys.has(`${ep.method} ${ep.path}`));
        if (coveredEndpoints.length > 0) {
          sections.push(
            "## Covered Endpoints (already tested)",
            "",
            ...coveredEndpoints.map(
              (ep) => `- ${ep.method} ${ep.path}${ep.summary ? ` — ${ep.summary}` : ""}`,
            ),
            "",
          );
        }
      }
    } catch (err) {
      console.log(
        `${colors.yellow}Warning: Could not parse OpenAPI spec: ${
          err instanceof Error ? err.message : err
        }${colors.reset}`,
      );
    }
  } else {
    sections.push(
      "## OpenAPI Spec",
      "",
      "No OpenAPI spec found. To enable coverage analysis and endpoint schema inclusion,",
      "add an `openapi.json`, `openapi.yaml`, or `openapi.yml` file to the project root,",
      "or pass `--openapi <path>` to this command.",
      "",
    );
  }

  // Write output
  const content = sections.join("\n");
  const outputDir = outputPath.substring(0, outputPath.lastIndexOf("/"));
  await Deno.mkdir(outputDir, { recursive: true });
  await Deno.writeTextFile(outputPath, content);

  console.log(
    `\n${colors.green}Context written to: ${relative(dir, outputPath)}${colors.reset}`,
  );
  console.log(
    `${colors.dim}Reference it in Cursor with: @${relative(dir, outputPath)}${colors.reset}\n`,
  );
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/**
 * Check if a trace URL matches an OpenAPI endpoint.
 */
function matchesEndpoint(
  traceUrl: string,
  traceMethod: string,
  ep: Endpoint,
): boolean {
  if (ep.method.toUpperCase() !== traceMethod.toUpperCase()) return false;
  let urlPath: string;
  try {
    urlPath = new URL(traceUrl).pathname;
  } catch {
    urlPath = traceUrl.startsWith("/") ? traceUrl : `/${traceUrl}`;
  }
  if (urlPath.length > 1 && urlPath.endsWith("/")) {
    urlPath = urlPath.slice(0, -1);
  }
  const escaped = ep.path.replace(
    /[.*+?^${}()|[\]\\]/g,
    (m) => m === "{" || m === "}" ? m : `\\${m}`,
  );
  const pattern = escaped.replace(/\{[^}]+\}/g, "[^/]+");
  try {
    return new RegExp(`^${pattern}$`).test(urlPath);
  } catch {
    return false;
  }
}

/**
 * Generate a JSON example from a schema definition.
 */
function schemaToExample(schema: SchemaInfo): unknown {
  if (schema.enum && schema.enum.length > 0) {
    return schema.enum[0];
  }

  switch (schema.type) {
    case "string":
      return schema.format === "date-time"
        ? "2026-01-01T00:00:00Z"
        : schema.format === "email"
        ? "user@example.com"
        : schema.format === "uri"
        ? "https://example.com"
        : "string";
    case "integer":
    case "number":
      return 0;
    case "boolean":
      return true;
    case "array":
      if (schema.items) {
        return [schemaToExample(schema.items)];
      }
      return [];
    case "object":
    default:
      if (schema.properties) {
        const obj: Record<string, unknown> = {};
        for (const [key, prop] of Object.entries(schema.properties)) {
          obj[key] = schemaToExample(prop);
        }
        return obj;
      }
      return {};
  }
}

/**
 * Try to read a sample test file to include as a pattern reference.
 * Picks the first file with at least one test export.
 */
async function findSampleTest(
  dir: string,
  // deno-lint-ignore no-explicit-any
  fileEntries: [string, any][],
): Promise<string | null> {
  // Find the first test file
  for (const [filePath] of fileEntries) {
    try {
      const fullPath = resolve(dir, filePath);
      const content = await Deno.readTextFile(fullPath);
      // Extract the first test definition (between export const and the closing );)
      const match = content.match(
        /export\s+const\s+\w+\s*=\s*test(?:Case)?\s*\([^]*?\n\);/,
      );
      if (match) {
        // Limit to reasonable size
        const sample = match[0];
        if (sample.length <= 2000) {
          return sample;
        }
        // Truncate long samples
        const lines = sample.split("\n");
        if (lines.length > 40) {
          return [
            ...lines.slice(0, 30),
            "    // ... (truncated)",
            "  }",
            ");",
          ].join("\n");
        }
        return sample;
      }
    } catch {
      // Can't read file, skip
    }
  }
  return null;
}
